> ## [C# 托管资源与非托管资源](https://www.cnblogs.com/enamorbreeze/p/4711468.html)
>
> 在.net 编程环境中，系统的资源分为托管资源和非托管资源。
>
> #### 一句话总结:托管资源就是大部分C#的对象,成员变量等,托管给.NET的GC管理器,在不需要的时候回收掉他,非托管资源就是类似系统上的网络,文件,打开之后需要及时的关闭,这部分资源不会被GC回收,如果不手动关闭则会一直占用内存.
>
> **托管资源：**
>
> Net平台中，CLR为程序员提供了一种很好的内存管理机制，使得程序员在编写代码时不要显式的去释放自己使用的内存资源（这些在先前C和C++中是需要程序员自己去显式的释放的）。这种管理机制称为GC(garbage collection)。GC的作用是很明显的，当系统内存资源匮乏时，它就会被激发，然后自动的去释放那些没有被使用的**托管资源**（也就是程序员没有显式释放的对象）。
>
>  
>
> 所以托管就是.net framework 负责帮你管理内存及资源释放，不需要自己控制，当然**对象只针对托管资源（部分引用类型）, 不回收非托管资源**。 像数组，用户定义的类、接口、委托，object，字符串等引用类型，栈上保存着一个地址而已，当栈释放后， 即使对象已经没有用了，但**堆上分配的内存还在**，只能等**GC收集时才能真正释放** ；但注意int,string,float,DateTime之类的值类型，GC会**自动释放**他们占用的内存，不需要GC来**回收释放**
>
>  
>
> 那么非托管的资源怎么释放回收呢？
>
>
> **非托管资源：** 
>
> 对于非托管资源，**GC只能跟踪非托管资源的生存期，而不知道如何去释放它**。这样就会出现当资源用尽时就不能提供资源能够提供的服务，windows的运行速度就会变慢。比如当你链接了数据库，用完后你没有显式的释放数据库资源，如果还是不断的申请数据库资源，那么到一定时候程序就会抛出一个异常。
>
> 
> 所以，当我们在类中封装了对非托管资源的操作时，**我们就需要显式，或者是隐式的释放这些资源**。**在.Net中释放非托管资源主要有2种方式，Dispose，Finalize，**而Finalize和Dispose方法分别就是隐式和显式操作中分别使用到的方法。
>
> 例如文件流，数据库的连接，系统的窗口句柄，打印机资源等等，当你读取文件之后，就需要对各种Stream进行Dispose等操作。比如 SqlDataReader 读取数据完毕之后，需要 reader.Dispose();等
>
>  
>
> Finalize一般情况下用于基类不带close方法或者不带Dispose显式方法的类，也就是说，在Finalize过程中我们需要隐式的去实现非托管资源的释放，然后系统会在Finalize过程完成后，自己的去释放托管资源。在.NET中应该尽可能的少用析构函数释放资源，MSDN2上有这样一段话:实现 Finalize 方法或析构函数对性能可能会有负面影响，因此应避免不必要地使用它们。**用 Finalize 方法回收对象使用的内存需要至少两次垃圾回收**。所以有析构函数的对象，需要两次，第一次调用析构函数，第二次删除对象。而且在析构函数中包含大量的释放资源代码，会降低垃圾回收器的工作效率，影响性能。**所以对于包含非托管资源的对象，最好及时的调用Dispose()方法来回收资源**，而不是依赖垃圾回收器。