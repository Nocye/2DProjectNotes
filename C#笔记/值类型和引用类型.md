**值类型** 只需要一段单独的内存,用于储存实际的数据

**引用类型** 需要两段内存 

第一段储存实际的数据,它总是位于堆中,

第二段是一个引用,指向数据在堆中的位置

**一般情况**下,值类型的数据存放在栈中.引用类型的数据存放在堆中,而引用存放在栈中

引用类型对象的数据部分是始终存放在堆里.

值类型对象,或引用类型数据的引用部分可以放在堆里,也可以放在栈里,取决于实际环境.

假设一个类MyType 含有两个成员,值类型的A与引用类型的B

A是值类型,但它是MyType实例数据的一部分,所以和对象数据一起存放在堆里

B是引用类型,它的数据始终在堆里,但他的引用也放在堆中,封装在MyType对象的数据中

* 数组类型是引用类型,即使元素是值类型
* 枚举是值类型
* 委托类型是引用类型
* 接口类型是引用类型,但可由值类型实现



### 对象在c#中默认是通过引用传递

这是一个误区,实际上对象的传递默认是通过值类型传递,只不过传递的是对象的引用,引用指向了对象,所以以下代码不会成立

```c#
StringBuilder strB = new StringBuilder("初始字符串"); 
Append(strB);
void Append(StringBuilder buider){
	buider=null;
}
```

实际上strB并不会被置为null,

因为传递的是strB引用的复制,置为null的是局部变量builder 这个行为无意义

如果有这样的需求,可以使用ref参数,使用引用传递

![](https://raw.githubusercontent.com/Nocye/ImageBed/master/20200716115549.png)