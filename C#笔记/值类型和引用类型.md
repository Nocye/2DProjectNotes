**值类型** 只需要一段单独的内存,用于储存实际的数据

**引用类型** 需要两段内存 

第一段储存实际的数据,它总是位于堆中,

第二段是一个引用,指向数据在堆中的位置

**一般情况**下,值类型的数据存放在栈中.引用类型的数据存放在堆中,而引用存放在栈中

引用类型对象的数据部分是始终存放在堆里.

值类型对象,或引用类型数据的引用部分可以放在堆里,也可以放在栈里,取决于实际环境.

假设一个类MyType 含有两个成员,值类型的A与引用类型的B

A是值类型,但它是MyType实例数据的一部分,所以和对象数据一起存放在堆里

B是引用类型,它的数据始终在堆里,但他的引用也放在堆中,封装在MyType对象的数据中

* 数组类型是引用类型,即使元素是值类型
* 枚举是值类型
* 委托类型是引用类型
* 接口类型是引用类型,但可由值类型实现



### 对象在c#中默认是通过引用传递

这是一个误区,实际上对象的传递默认是通过值类型传递,只不过传递的是对象的引用,引用指向了对象,所以以下代码不会成立

```c#
StringBuilder strB = new StringBuilder("初始字符串"); 
Append(strB);
void Append(StringBuilder buider){
	buider=null;
}
```

实际上strB并不会被置为null,

因为传递的是strB引用的复制,置为null的是局部变量builder 这个行为无意义

如果有这样的需求,可以使用ref参数,使用引用传递

![](https://raw.githubusercontent.com/Nocye/ImageBed/master/20200716115549.png)



如果对一个值类型变量调用GetType（）方法，那么会默认装箱成object类型后，再调用GetType（），因为CLR必须使用指向对象类型的指针，这个指针只能通过装箱成object来获得。

### 值类型的装箱和拆箱

值类型比引用类型要“轻”，因为它不在托管堆中分配，不需要被GC，也不通过内存指针进行引用。如果部分情况下需要通过引用来获取一个值类型的参数，就需要进行装箱。在装箱时需要以下几个步骤：

1. 在托管堆中分配内存。分配的内存量是值类型各字段所需要的内存量，再加上托管堆所有对象的两个额外成员（Type实例指针和同步块索引）所需的内存量。（类似new一个类，用一个其中一个字段来保存）
2. 值类型的字段复制到新分配的内存中。
3. 返回内存地址。现在这个地址代表对象引用，值类型变成了引用类型。

拆箱时，获取已装箱对象中的各个字段的地址。再把这些字段包含的值从堆复制到栈中的值类型实例中。

需要注意的是，拆箱指的是获取装箱对象中各字段的地址，后续的复制发生在赋值给用来接收的变量。

拆箱时内部发生以下事：

1. 如果“对以装箱值类型实例的引用”的变量为null，抛出空应用错误（NullReferenceException）。
2. 如果引用的对象不是所需值类型的已装箱实例，抛出强转无效的错误（InvalidCastException）。

拆箱时的类型必须要和装箱时的类型一致，哪怕其他类型到这个类型有隐式转换。

##### 值类型的new，是不会产生GC的

```c#
struct SomeVal
{
	int x;
}
SomeVal v1 = new SomeVal(); //CLR发现是值类型，在栈上分配，不会产生GC，内部所有字段初始化值为0
```

如果你的结构体不需要与非托管代码进行交互，请加上 [StructLayout(LayoutKind.Auto)]这个特性，这个特性告诉CLR可以为这个结构自动选择最优的内存布局。

##### == 运算符

默认情况下，计算两个引用类型是否引用同一个对象，通过IL指令ceq。

如果引用类型重载了==运算符，使用Object.ReferenceEquals方法来检查是否引用同一对象。

自定义结构默认情况下不支持==运算符，用户必须重载==才可以使用。