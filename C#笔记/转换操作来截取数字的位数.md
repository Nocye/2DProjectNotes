已知c#中整数类型有以下几种

| int   | 32 位有符号整数类型 | -2,147,483,648 到 2,147,483,647                         | 0    |
| ----- | ------------------- | ------------------------------------------------------- | ---- |
| long  | 64 位有符号整数类型 | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 | 0L   |
| uint  | 32 位无符号整数类型 | 0 到 4,294,967,295                                      | 0    |
| ulong | 64 位无符号整数类型 | 0 到 18,446,744,073,709,551,615                         | 0    |
| byte  | 8 位无符号整数      | 0 到 255                                                | 0    |

一个高位数整数转换为低位数整数时,会把超过低位数上限的二进制值全部舍弃掉,使用这个特点来实现切割二进制值

以uint举例,32位包含4个8位的byte值,假设我们需要提取出每8位的一个byte值,

```csharp
uint number=16843009;
//通过强转为byte值,舍弃掉八位以上的位数,得出一个只包含低8位的值
uint temp=(byte)(number);
```

在第二次提取时,需要跳过前面已经被提取的八位数,这时候可以加上右移符号,就可以精确切分一段二进制值中你想要的位数

```csharp
uint temp=(byte)(number>>8)
```

##### 例题:

IPv4 地址是由 32 位二进制数组成，为便于使用，常以 x.x.x.x 形式表现，每 8 位用 0 – 255 的十进制数表示，例如 16843009 表示 1.1.1.1 或 3232235784 表示 192.168.1.8 等，请写一段程序，将输入 uint 整数处理成以 x.x.x.x 表示的字符串。

题目的0-255可以直接理解为是一个byte值,也就是说IP是通过把一个uint值切分为四个byte值来代表的,

(为何不是int?)因为int最高位是符号位,

```csharp
        public static string ConvertIP(uint number)
        {
            StringBuilder result = new StringBuilder();
            for (int i = 3; i >= 0; i--)
            {
                //强转byte后,只取低八位,抛弃其他的二进制位数
                //右移8位后,再通过强转为byte,截取低8位数
                result.Append((byte) (number >> i * 8));
                result.Append((i > 0 ? "." : string.Empty));
            }
            return result.ToString();
        }
```

